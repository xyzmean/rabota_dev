AutoSched – Улучшенная система автогенерации графика работы сотрудников магазина
Обзор и цели улучшений
AutoSched – это новая архитектура автоматического генератора расписаний для сотрудников магазина, полностью переработанная по сравнению с предыдущей версией (см. RABOTA_SCHED). Основная цель – создать гибкую, надежную и оптимизированную систему планирования смен, учитывающую множество правил и ограничений. В новой версии учтены лучшие практики существующих решений (например, Kronos, Deputy, Shiftboard, When I Work и др.), интегрированы современные методы оптимизации (Constraint Satisfaction, Linear Programming, локальные оптимизационные алгоритмы) и предусмотрена улучшенная UX-функциональность для менеджеров. Система обеспечивает поддержку настраиваемых правил валидации расписания, учитывает запросы сотрудников на выходные дни и предоставляет удобные инструменты для обнаружения и разрешения конфликтов прямо в интерфейсе.
Ключевые улучшения:
•	Гибкая конфигурация правил и ограничений. Все бизнес-правила (требования к составу смен, нагрузке сотрудников, перерывы, пожелания и пр.) вынесены в настраиваемые параметры. Правила можно задавать и изменять без изменения кода – через конфигурацию/БД. Предусмотрены уровни строгости правил (предупреждение или запрет) по аналогии с системами вроде Kronos.
•	Интеллектуальный алгоритм планирования. Вместо прежней простой последовательной логики применяется алгоритм оптимизации, рассматривающий расписание целиком. Используются подходы CSP/ILP: генератор пытается найти оптимальный график, удовлетворяющий максимальному числу ограничений с учетом их приоритетов. При поиске расписания система способна учитывать сложные ограничения (например, минимальный отдых между сменами, баланс часов, обязательные роли) и соблюдать их автоматически.
•	Интеграция запросов на выходные. Запросы сотрудников на выходные (отпуск, отгулы) теперь полноценно учитываются при генерации. Одобренные запросы воспринимаются как жёсткие ограничения (сотрудник не должен ставиться на смену в этот день). Система способна выявлять конфликтные ситуации – например, если одновременно одобрено слишком много выходных, нарушающих покрытие смен – и уведомлять об этом менеджера. В перспективе возможна автоматическая обработка pending-запросов: алгоритм может решать, какие запросы удовлетворить, если все сразу удовлетворить невозможно, исходя из приоритетов причин и необходимости покрытия смен.
•	Усовершенствованный UX для планировщика. В интерфейсе планирования реализованы визуальные индикаторы нарушений правил (конфликтов) и приоритетов. Менеджер видит, какие смены не соответствуют требованиям (например, недостаточно сотрудников или нарушен максимум подряд смен) – эти ячейки подсвечиваются и снабжены подсказками. Для правил-разрешений (warning) отображаются предупреждения, не блокирующие сохранение графика, тогда как для обязательных правил (error) система предотвращает финализацию расписания до устранения проблемы. Предусмотрены уведомления: например, оповещения сотрудникам о новых сменах, уведомления менеджеру об оставшихся незаполненных сменах или о конфликтах при автогенерации. Также поддерживается удобная ручная правка: менеджер может перетаскивать сотрудников между сменами или вводить корректировки, а система тут же обновляет статус правил (пересчитывает нарушения) в реальном времени.
•	Примеры конфигурации. Документ содержит примеры JSON-конфигураций для правил, примеры SQL-структуры БД и диаграммы, поясняющие архитектуру и алгоритмы. Это позволяет получить целостное представление о системе на уровне инженерной спецификации: от хранения данных до процессов генерации расписания.
Ниже подробно описаны архитектура компонентов AutoSched, система правил валидации, набор типовых правил и алгоритм генерации расписания с учетом приоритетов.
Архитектура системы
AutoSched построен по принципу клиент-серверного приложения. В качестве стека технологий используются: Frontend: React 19.2.0 + TypeScript 5.9.3 (сборка через Vite 7.2.2, маршрутизация – React Router 7.9.6, стили – Tailwind CSS и PostCSS, иконки – lucide-react); Backend: Node.js 20.x + Express 5.x; Database: PostgreSQL 15 (доступ через pg 8.16.3). Приложение разворачивается в контейнерах Docker, с использованием Nginx как reverse proxy/static host и PM2 для управления процессами Node.js в продакшене. Ниже приведено описание основных компонентов и модулей.
Фронтенд (React) и UX-функции
Интерфейс расписания. Клиентское приложение предоставляет интерактивный календарь/таблицу смен на период (например, помесячное расписание). Сетка расписания отображает дни по горизонтали и список сотрудников по вертикали (либо наоборот, в зависимости от UX-дизайна), с указанием смен каждого сотрудника. Менеджер может переключаться между видами (например, помесячный обзор или поквартально) и фильтровать отображение по должностям или отделам.
•	Отображение приоритетов и конфликтов. В UI реализованы визуальные маркеры правил. Если расписание сгенерировано автосоставлением, система может выделить области, где нарушены правила. Например, если на смене недостаточно людей, её ячейка подсвечивается красным (error) с подсказкой о минимуме сотрудников. Если сотрудник поставлен на слишком много смен подряд, соответствующие ячейки отмечаются предупреждением. У каждого правила в конфигурации задан уровень строгости – предупреждение (неблокирующее) или ошибка (блокирующее). В интерфейсе это отражается разными цветами/иконками (например, жёлтый треугольник для предупреждений, красный знак «стоп» для ошибок). Менеджер может открыть панель «Валидация расписания», где перечислены все выявленные нарушения с указанием правила и затронутых смен/сотрудников.
•	Редактирование и ручная корректировка. Хотя AutoSched генерирует расписание автоматически, важной частью UX является возможность его поправить. Интерфейс позволяет вносить изменения вручную: перетаскивать сотрудника в другую смену, добавлять/удалять выходные дни, менять роли внутри смены и т.д. При каждой правке фронтенд мгновенно валидирует новые изменения локально (или посредством быстрого API-вызова) на предмет нарушений правил. Например, если менеджер пытается поставить сотрудника на шестой день подряд, приложение сразу покажет предупреждение или не позволит сохранить такую правку, в зависимости от настроек правила. Таким образом достигается интерактивная проверка, похожая на поведение Kronos, где система может либо лишь информировать о нарушении, либо блокировать сохранение графика при определенных уровнях правил.
•	Уведомления и взаимодействие. Система поддерживает оповещения для эффективного взаимодействия с пользователями. Примеры:
•	После финализации расписания менеджер может одним кликом уведомить всех сотрудников (например, через email или push) о новом графике.
•	Сотрудники получают уведомления, если их запрос на выходной был одобрен/отклонён, либо если им назначена смена в выходной, который они запрашивали (при условии, что запрос не был удовлетворён).
•	Если автогенерация не смогла заполнить все смены (например, остались незакрытые позиции или требуемые роли), менеджер получит уведомление/подсказку об этих «дырах» в расписании для дальнейшего ручного заполнения.
•	Встроена функция комментариев/примечаний: менеджер может оставить заметки по смене (например, «требуется подмена на этой позиции»), которые видны другим менеджерам или сотрудникам (в зависимости от контекста).
•	Учет предпочтений сотрудников. При включенной функции «учет предпочтений» интерфейс может позволять сотрудникам через свой аккаунт указать желаемые или нежелательные смены/дни (например, предпочитаю утренние смены, не могу работать по понедельникам после 18:00 и т.п.). Эти предпочтения отображаются менеджеру (например, в виде цветовых меток: зеленая стрелка – предпочитаемая смена, красная – нежелательная) и учитываются автосоставителем как мягкие ограничения. Таким образом, интерфейс способствует учету интересов сотрудников, повышая их удовлетворенность расписанием.
Бэкенд (Node.js, Express) и API
Серверная логика. Backend реализует REST API для всех функций системы. Основные модули включают: - autoScheduleController.ts – эндпоинты для автогенерации расписания (POST /api/auto-schedule). Основной метод generateSchedule() извлекает исходные данные (сотрудников, шаблоны смен, правила, одобренные выходные) и запускает алгоритм построения расписания. После успешной генерации сохраняет расписание в БД. - scheduleController.ts – CRUD-операции над конкретными сменами/расписанием (например, ручное редактирование отдельной записи расписания через API, если правка идет не из UI напрямую). - rulesController.ts – эндпоинты для получения/обновления конфигурации правил. Администратор может через UI добавить новое правило или изменить параметры существующего (например, повысить максимум смен в неделю). Все правила хранятся в БД (подробнее – в разделе про данные) и могут динамически учитываться алгоритмом без перекомпиляции кода. - preferencesController.ts и preferenceReasonsController.ts – управление запросами на выходные и справочником причин (на основе старой реализации). POST /api/preferences позволяет сотруднику подать новый запрос (на frontend есть соответствующая форма и модальное окно), а менеджер может утвердить или отклонить запрос через PUT /api/preferences/{id} (меняя статус на approved или rejected). Одобрение автоматически влечет пометку, что в конкретный день данный сотрудник недоступен для планирования смен.
Бизнес-логика генерации. Ядром backend является сервис автосоставления расписания. Он выделен в отдельный модуль (например, schedulerService.ts) и может вызываться как синхронно по запросу, так и по расписанию (например, автогенерация графика на новый месяц). Основные шаги работы генератора: 1. Загрузка данных. Из БД выбираются все сотрудники (активные, с их ролями, ставками и др.), все шаблоны смен (типичные смены с временем начала/окончания, а также специальная псевдосмена «day-off» для выходного), актуальные правила валидации (включенные, с заданными параметрами и приоритетами) и утверждённые выходные дни сотрудников на планируемый период. 2. Подготовка к планированию. Перед генерацией очищается старый график за период (если он есть). Затем в алгоритме сразу «бронируются» дни, где у сотрудников одобрены выходные: каждому такому случаю в результирующем расписании добавляется запись о выходном (shift_id = 'day-off'). Эти сотрудники помечаются как недоступные в соответствующие даты. (Если слишком много сотрудников получили выходной в один день, что нарушает минимальную численность на сменах, алгоритм далее сможет выявить, что правило min_employees нарушается, и пометит проблему – либо предложит сдвинуть чьи-то выходные, если возможно). 3. Основной цикл генерации расписания. Далее сервис пытается распределить всех сотрудников по оставшимся незаполненным сменам с учетом ограничений. Здесь внедрены методы оптимизации: - Постановка задачи как CSP/ILP. Система формализует расписание как набор переменных и ограничений. Например, вводится бинарная переменная X(employee, day, shift) для каждого сотрудника и смены дня, равная 1 если сотрудник назначен, 0 иначе. Накладываются ограничения: каждый сотрудник максимум на одну смену в день, в каждой смене должно быть не менее N и не более M сотрудников, сотрудник не работает более 5 дней подряд, и т.д. – согласно набору правил. Некоторые ограничения являются жесткими (hard constraints, например, «не более одной смены в день на сотрудника» или «не ставить в расписание в день одобренного выходного»), другие – мягкими (soft constraints, например, «учитывать пожелание сотрудника не работать в выходной»). Жесткие ограничения добавляются как строгие уравнения/неравенства, мягкие – через штрафы в целевой функции. Формируется целевая функция оптимизации, которая максимизирует степень выполнения мягких правил. Для учета приоритетов правил используются весовые коэффициенты: чем выше приоритет, тем больший «штраф» за его нарушение. Например, нарушение правила высокой важности может добавлять к целевой функции большой штраф, чтобы планировщик избегал его всеми силами. Такой подход позволяет найти расписание, максимизирующее число соблюденных (или минимизирующее суммарное нарушение) правил в порядке важности – фактически, реализуя принцип «сначала удовлетворяем верхние правила, по возможности жертвуя нижними». (Альтернатива – многоэтапная оптимизация: сначала фиксируем выполнение самых приоритетных ограничений, затем оптимизируем по следующим и т.д., что эквивалентно лексикографической оптимизации.) - Использование решателя. После формирования модели, система может воспользоваться встроенным решателем. В Node.js можно интегрировать библиотеку линейного программирования (например, минималистичный LP-солвер на JavaScript) или вызвать внешнюю службу. Допускается, например, вызов Python-скрипта с Google OR-Tools CP-SAT через child process, либо использование готовых REST API (как Google Optimization API или OptaPlanner) – но в рамках текущего стека предпочтительно open-source решение. В сложных случаях, если задача очень большая, можно переключиться на эвристический алгоритм. - Локальные эвристики (Greedy/Local Search). Для средних по размеру задач (магазин с десятками сотрудников) ILP/CP решатель справится оптимально. Однако на всякий случай реализован резервный подход: жадный алгоритм + локальная оптимизация. Жадный алгоритм может, например, итеративно заполнять дни: сортировать сотрудников по некоему приоритету и назначать их на доступные смены, стараясь удовлетворить ключевые правила. В предыдущей версии использовался приоритет: сотрудники, которым нужен отдых, далее с наименьшим числом подряд рабочих дней и наименьшим числом смен в месяце имели больший приоритет на получение выходного. В новой версии подход усложняется – жадный шаг учитывает множество факторов (веса правил). После начального построения расписания выполняется этап локального улучшения: проверяются нарушения правил и предпринимаются попытки их устранить перестановкой отдельных сотрудников между сменами или обменом смен. Здесь могут применяться стратегии локального поиска: Tabu Search, Simulated Annealing и др., чтобы найти лучший вариант расписания без глобороссмотра всего пространства перебором. 4. Применение правил приоритетно. Алгоритм стремится в первую очередь удовлетворить самые важные правила. Например, правило покрытие смены минимальным числом сотрудников явно критично для бизнеса – оно будет с приоритетом 1 и фактически станет жёстким ограничением (если не выполняется, решение недопустимо). Правило учет предпочтений сотрудников может быть мягким с более низким приоритетом – алгоритм постарается его выполнить, но не ценой срыва покрытия смен или нарушения ограничений по трудовому законодательству. В итоге, если идеального решения, удовлетворяющего всем требованиям, не существует, AutoSched гарантирует максимальное выполнение верхнеуровневых правил и минимальное возможное нарушение низкоприоритетных. Например: предположим, заданы правила (по убыванию приоритета) – (1) минимум сотрудников на смене, (2) не больше 5 рабочих дней подряд для любого сотрудника, (3) учет пожеланий по выходным. Если в конкретную субботу слишком мало людей доступно и приходится вызвать сотрудника на 6-й день подряд, чтобы магазин открылся, то правило (2) будет нарушено, но (1) выполнено. Система пометит это как предупреждение (если правило (2) помечено как warning) и предложит, возможно, выбрать меньшее зло – например, кого из сотрудников меньше перегрузить. Но она не нарушит правило (1), так как оно приоритетнее, и не оставит смену пустой. 5. Выходные заявки и их влияние. Одобренные запросы на выходной внедрены в алгоритм как обязательные ограничения: сотрудник $i$ в день $d$ не может иметь рабочую смену (переменная X(i,d,shift) должна быть 0 для всех рабочих shift). Таким образом, алгоритм автоматически удовлетворяет все approved-запросы. Если это приводит к тому, что в день $d$ не хватает персонала, то нарушение произойдет по другому правилу (например, min_employees_per_shift) и будет явно зафиксировано. Менеджер на этапе результатов увидит, что, скажем, «Правило: минимум 3 сотрудника в смене – нарушено 5 января (только 2 доступны из-за одобренных отгулов)». Он сможет либо скорректировать ранее одобренные заявки (перевести какие-то в статус rejected по согласованию с сотрудниками), либо добавить резервного сотрудника/стажера на этот день. В будущем планируется улучшить этот процесс: например, предоставлять менеджеру автоматизированный «помощник по выходным», который проанализирует все pending-заявки и предложит, какие можно одобрить без ущерба для расписания. Это по сути решается тем же алгоритмом планирования, но с дополнительным шагом оптимизации по максимальному удовлетворению запросов работников. 6. Сохранение результатов. После того, как решение получено (либо оптимальное, либо приближенное), оно сохраняется в базу данных. Каждая назначенная смена добавляется как запись (employee_id, date, shift_id и т.д.) в таблицу расписания. Если какие-то смены остались незаполненными (в случае использования опций, разрешающих пустые смены), они тоже фиксируются особым образом или остаются для ручного заполнения. Сохранение происходит транзакционно – сначала очищаются старые записи целевого месяца, затем вставляются новые. После сохранения расписание доступно для просмотра на фронтенде, и система отправляет оповещение (например, веб-сокет событие или push) о том, что новое авто-расписание готово.
Структура данных и пример конфигурации
На стороне PostgreSQL хранится основная информация: список сотрудников, доступные шаблоны смен, правила валидации, расписание и заявки на выходные. Ниже описаны ключевые сущности и приведены примеры.
•	Сотрудники – таблица employees со столбцами: id (UUID первичный ключ), name, role (должность/роль, например «кассир», «старший смены»), возможно contract_hours (норма часов или ставок, если нужно учитывать). Дополнительно могут храниться атрибуты, влияющие на расписание: например, флаг isMinor (несовершеннолетний – чтобы применять особые правила ограничения по времени), навыки/сертификаты.
•	Роли/должности – может быть справочник roles (role_id, name) и связь many-to-many между сотрудниками и ролями, если один сотрудник может совмещать несколько ролей. В простом случае роль хранится как поле у сотрудника.
•	Шаблоны смен – таблица shifts с описанием каждой типовой смены. Поля: id (например, «morning», «evening», или числовой), name (отображаемое название, например «Утренняя смена»), start_time, end_time (время в сутках), store_id (если расписание для нескольких магазинов), а также min_staff и max_staff – минимально/максимально требуемое число сотрудников на этой смене. Также можно иметь связанный список требуемых ролей для смены: например, таблица shift_roles_requirements(shift_id, role, min_count), куда занести, что для смены "evening" нужно минимум 1 старший кассир. Эти требования будут преобразованы в соответствующие правила при генерации.
•	Расписание – таблица schedule_entries (или employee_shifts). Поля: id, employee_id, date (DATE), shift_id. Каждая запись означает назначение сотрудника на конкретную смену конкретного дня. Также можно сохранять мета-информацию: assigned_by (auto или user – кем назначено), violation (NULL или код правила, если эта запись нарушает какое-то правило; хотя, скорее, нарушения вычисляются на лету, а не хранятся). При необходимости, можно добавить поле status (например, draft или published – чтобы сначала сгенерировать и отредактировать расписание как черновик, а потом опубликовать).
•	Правила валидации – таблица validation_rules хранит набор настраиваемых правил. Пример структуры:
 	CREATE TABLE validation_rules (
  id            SERIAL PRIMARY KEY,
  code          TEXT,       -- код правила, например "min_employees_per_shift"
  description   TEXT,       -- описание (для UI), напр. "Минимум сотрудников на смене"
  scope         TEXT,       -- область применения: 'global', 'role' или 'individual'
  target_role   TEXT,       -- если scope='role', тут хранится должность/роль
  target_employee UUID,     -- если scope='individual', тут ID сотрудника
  enforcement   TEXT,       -- 'error' или 'warning'
  priority      INTEGER,    -- приоритет (меньшее число = выше важность)
  params        JSONB,      -- параметры правила (лимиты, окна и пр., в формате JSON)
  enabled       BOOLEAN     -- флаг включенности данного правила
);
 	Каждый записанный здесь rule интерпретируется движком планирования. Например, запись:
 	{
  "code": "min_employees_per_shift",
  "scope": "global",
  "enforcement": "error",
  "priority": 1,
  "params": { "min": 2 }
}
 	означает правило «Минимум 2 сотрудника на любую смену», применимое ко всем (глобальное) с высоким приоритетом и жестким требованием (ошибка при нарушении). Другой пример:
 	{
  "code": "max_consecutive_work_days",
  "scope": "individual",
  "target_employee": "UUID_сотр_Иванова",
  "enforcement": "warning",
  "priority": 5,
  "params": { "max_days": 5 }
}
 	– правило «Индивидуальное ограничение: Иванов не более 5 рабочих дней подряд», оформленное как предупреждение невысокого приоритета (возможно, для сотрудника-студента). Подобным образом можно задавать и отключать разнообразные валидаторы, не меняя код. Уровень гибкости правил сопоставим с решениями Kronos, где существуют Employee Rules (правила на уровне сотрудника, напр. ограничения по часам работы несовершеннолетних) и Organizational Rules (правила для локации или должности, напр. требование обязательного навыка на смене). В Kronos также поддерживаются уровни серьёзности правил – информационные, предупреждения или запретительные – что аналогично полю enforcement у нас.
•	Запросы на выходные – таблица day_off_requests. Поля: id, employee_id, date, status (pending/approved/rejected), reason_id (опционально – ссылка на спр. причин, например «Отпуск», «Больничный», «Личный»), priority (числовой приоритет, вычисляемый из причины – напр. у причины «Больничный» приоритет выше, чем у «Отгул»). При одобрении запроса запись меняет статус на approved и становится основанием для авто-планировщика не трогать данного человека в указанный день. Отклоненные – игнорируются при составлении графика. Pending-запросы на этапе генерации либо игнорируются, либо (опционально) могут учитываться как пожелания (soft constraints) – в зависимости от настроек системы. После генерации менеджер может видеть, какие pending остались невыполненными, и при необходимости утвердить/отклонить их.
Все связи между таблицами поддерживаются через внешние ключи (например, schedule_entries.employee_id -> employees.id). Для ускорения вычислений, могут быть добавлены представления или агрегаты, например, представление employee_schedule_stats с подсчетом смен каждого сотрудника за период, максимальной подряд серией и т.п., чтобы быстро оценивать баланс нагрузки.
Гибкие правила валидации и их настройка
Одно из основных требований новой версии – все правила проверки расписания должны быть полностью настраиваемыми. Это достигается через описанную выше модель validation_rules. Ниже разъясняется, как задаются разные аспекты правила и какие типы правил предусмотрены.
Параметры правила и область действия
Каждое правило валидации определяется следующими атрибутами:
•	Код правила (code): машиночитаемый идентификатор правила, определяющий логику проверки. Примеры: min_employees_per_shift, max_shifts_per_week, no_night_for_minors и т.д. Код определяет, каким образом движок будет интерпретировать params.
•	Описание (название): человекочитаемое название для UI, чтобы менеджер понимал, что это за правило (например, "Максимум смен в неделю").
•	Область применения (scope): определяет, к каким сотрудникам или сменам применяется правило. Возможные значения:
•	global – глобальное правило, применимое ко всему расписанию (например, "не более 6 рабочих дней подряд для любого сотрудника" – охватывает всех).
•	role – ролевое/организационное правило, действующее на конкретную должность или категорию сотрудников. Например, правило "в каждой смене должен быть минимум 1 сотрудник с ролью Менеджер" будет иметь scope = role и target_role = "Manager". Или правило "кассирам не ставить больше 30 часов в неделю" – также role-ограничение.
•	individual – индивидуальное правило для конкретного сотрудника. Например, "Иванову не ставить смены по воскресеньям" или "Максимум 20 часов в неделю для Петровой (по ее контракту)" – задаются как индивидуальные.
•	Конкретизация (target_role / target_employee): при scope = role указывается идентификатор роли/должности, при scope = individual – ID сотрудника. В случае global эти поля не используются.
•	Строгость (enforcement): режим применения правила – error или warning.
•	error (жесткое правило) означает, что нарушение недопустимо при финальном сохранении расписания. Автогенератор будет стремиться ни при каких условиях не нарушать такие правила. Если же нарушить неизбежно (нет решения без нарушения), эти нарушения будут явно отмечены как критические – менеджер должен либо скорректировать входные данные, либо вручную принять решение о компромиссе. Пример: правило "максимум 12 часов работы в день" должно быть жестким, т.к. связано с законодательством.
•	warning (мягкое правило) – рекомендация или предпочтение. Автогенератор старается удовлетворить и такие правила, но может их нарушить, если иначе нельзя соблюсти более важные условия. Нарушения помечаются в интерфейсе, но не препятствуют использованию расписания. Менеджер, увидев предупреждения, может при желании подправить график. Пример: "не назначать более 3 выходных за месяц одному сотруднику" – можно оформить как предупреждение.
•	(В будущем можно расширить градации – аналогично Kronos, где есть уровни "Informational", "Warning", "No Save" и пр. – но пока достаточно двух.)
•	Приоритет: числовой приоритет правила, определяющий его относительную важность. 1 – самый высокий приоритет, правила с большим числом менее важны. При конфликте между двумя мягкими правилами выигрывает более приоритетное. При конфликте мягкого с жестким – жесткое имеет приоритет по определению. Приоритет влияет на порядок применения в алгоритме: движок сначала удовлетворяет все правила с приоритетом 1, по возможности не жертвуя ими, затем оптимизирует по приоритету 2 и т.д. (как описано в разделе алгоритма). Если правило отключено (enabled = false), оно игнорируется (можно временно выключать правила из системы).
•	Параметры (params): JSON-объект с набором параметров, необходимых для конкретного правила. Структура и содержание params зависит от code:
•	Для правила типа "min_employees_per_shift" нужен параметр min (число). Возможна также вариация по сменам: например, указать минимумы отдельно для разных смен, тогда params может выглядеть как { "default": 2, "shiftOverrides": { "night": 3 } } (по умолчанию 2, но для ночной смены минимум 3).
•	Правило "max_shifts_per_week" может ожидать max (число смен) и опционально список дней, что считать неделей (например, { "max": 5, "per": "calendar_week" } – не более 5 смен в календарную неделю).
•	Правило "max_consecutive_work_days" – параметр max_days (сколько дней подряд разрешено работать).
•	Правило "shift_pattern" (шаблоны по дням) – может содержать структуру, описывающую шаблон недели. Например: { "Mon": ["morning","evening"], "Tue": ["morning","evening"], "Sun": [] } – что может значить «в воскресенье смен нет (выходной день для всех), в остальные дни две смены: утро и вечер». Однако такие паттерны скорее относятся к настройке самих смен/нагрузок, чем к проверке – их можно задавать на уровне shifts и shift_requirements.
•	Правило "cover_store_hours" – параметры могут включать часы работы магазина (если не брать их из другого места). Например: { "open": "08:00", "close": "22:00" }. Движок тогда проверит, что первая смена начинается не позже 08:00, а последняя заканчивается не раньше 22:00, либо что в каждый час из интервала есть хотя бы один сотрудник на смене.
•	Правило "balance_workload" – параметр, определяющий метрику баланса. Например: { "max_diff": 2 } – максимальная разница в количестве смен между любыми двумя сотрудниками не более 2. Либо { "target": "equal_shifts" }, что означает стремиться к равному числу смен (это скорее цель оптимизации, но можно превращать в правило с предупреждением, если кто-то сильно выбивается).
•	Правило "required_role_in_shift" – требуется указать role и min_count. Возможно, также shift если правило конкретно для определенной смены. Например: { "role": "Cashier", "min_count": 1 } – хотя бы один кассир в любой смене; либо { "role": "Manager", "shift": "night", "min_count": 1 } – на ночную смену минимум один менеджер.
•	Правило "day_off_requests" – по сути не требует параметров, а просто означает «не ставить смену, если есть одобренный запрос». Но раз это уже встроено как hard constraint, явное правило может не понадобиться. Однако для pending запросов можно ввести soft-правило: например, { "max_pending_day_off_per_day": 2 } – не более 2 пока неподтвержденных запросов на один день удовлетворяется. Это сложное правило, можно реализовать и вне алгоритма, но возможно.
•	Правило "employee_preferences" – может иметь параметр включения: { "respect_availability": true, "respect_shift_choice": true }. Тогда движок будет учитывать данные о предпочтениях/доступности сотрудников (например, не ставить в нерабочие для них часы – по сути это еще один вид ограничений по расписанию, похожий на "blacklist shifts" на уровне индивидуальной доступности).
•	Правило "even_distribution" – параметры могли бы быть: { "metric": "shifts_per_month", "tolerance": 1 } – выравнивать число смен в месяц с допустимой погрешностью 1. Нарушение этого можно сделать предупреждением.
•	Правило "blacklist_shifts" – ожидает список запрещенных для кого-то смен. Например, если scope = individual (для конкретного сотрудника) и code = "blacklist_shifts", params: { "shifts": ["night"] } – не ставить этому сотруднику ночные смены. Или scope = role: params: { "shifts": ["closing"], "reason": "AgeRestriction" } для правила "не назначать несовершеннолетних (role=Junior) на закрывающую смену после 21:00". Последнее фактически отражает законодательный запрет.
Настраивая таким образом params, администратор системы может покрыть очень широкий спектр ограничений, не внося правок в код. Новый сотрудник? – Добавили индивидуальные правила, если нужны. Новое правило законодательства? – Добавили запись в validation_rules. Изменились часы работы? – Обновили правило покрытия часов или шаблоны смен. Такой подход обеспечивает масштабируемость и гибкость.
Набор типовых правил валидации
Перечислим основные правила, которые AutoSched поддерживает "из коробки" и которые соответствуют типичным потребностям планирования графиков в ритейле. Все они могут быть представлены в описанном выше формате.
•	Минимум сотрудников на смене (min_employees_per_shift). Каждая рабочая смена должна быть укомплектована не менее чем N сотрудниками. N может зависеть от дня недели или типа смены (например, в выходные больше персонала). Правило глобальное или для конкретных смен. Как правило, enforcement = error, приоритет – один из самых высоких, ведь недостаток людей на смене напрямую влияет на работу магазина. Пример: min_employees_per_shift: { "min": 3 } (для всех смен каждый день минимум 3 человека).
•	Максимум сотрудников на смене (max_employees_per_shift). Ограничение сверху – обычно связано с бюджетом или здравым смыслом (нет необходимости ставить больше X человек, или физически столько рабочих мест нет). Может быть мягким правилом (warning), сигнализирующим о избыточном штате в смене. Но иногда может быть и жестким – например, чтобы не превышать установленный бюджет часов. Пример: max_employees_per_shift: { "max": 5 } (не более 5 человек на смене).
•	Минимум/максимум смен в неделю/месяц для сотрудника (min_shifts_per_period, max_shifts_per_period). Эти правила управляют нагрузкой на каждого отдельного сотрудника в заданном периоде (обычно неделя или месяц). Min полезен, например, для гарантии минимальной занятости (для контрактников или штатных сотрудников, которым нужно дать определенное число часов). Max – чтобы не перегружать и контролировать переработки/овертайм. Чаще используется max. Обычно задается отдельно на неделю и на месяц. Правила индивидуальные или ролевые (например, для частичной занятости другие лимиты). Enforcement может быть warning (если компания допускает исключения) или error (если строго запрещено, например, больше 40 часов в неделю). Примеры:
•	max_shifts_per_week: { "max": 5 } (не более 5 смен в неделю) – фактически эквивалентно правилу 5 рабочих дней и 2 выходных.
•	min_shifts_per_month: { "min": 15 } – гарантировать хотя бы 15 смен в месяц (например, для фулл-тайм сотрудников).
•	Ограничение по подряд сменам (max_consecutive_work_days). Правило, задающее максимально допустимую длину рабочей серии без выходных. Классический вариант – 5 рабочих дней подряд максимум, после чего должен быть хотя бы день отдыха. В некоторых случаях может быть 6 через 1 (суммарно не более 6). Это правило обычно жесткое (error), так как связано с выносливостью и зачастую трудовым кодексом. Пример: max_consecutive_work_days: { "max_days": 5 } (не более 5 дней подряд работать, на 6-й обязательно выходной). Движок должен проверять это для каждого сотрудника; при генерации он избегает ставить человека на 6-й день.
•	Минимальный отдых между сменами (min_rest_between_shifts). Другое важное правило (особенно если смены с явным временем начала/конца): требует, чтобы между окончанием одной смены и началом следующей у сотрудника был минимум X часов отдыха. Например, не менее 12 часов между сменами – чтобы человек, отработав вечер до 22:00, не вышел утром в 6:00. Это правило учитывает расписание по часам, и обычно жесткое (с точки зрения законодательства многие регионы требуют 11-часового перерыва). Пример: min_rest_between_shifts: { "hours": 12 }. Если график 24-часовой, то без такого правила система могла бы поставить человека на две смены с коротким промежутком, что недопустимо.
•	Шаблоны графика по дням недели (weekly_pattern). Это, скорее, комплекс правил или настроек, определяющих структуру расписания на неделю. Например, магазин может иметь фиксированный режим работы: Пн-Пт – полный день, Сб – укороченный, Вс – выходной. Можно задать, что по воскресеньям никто не работает (то есть все смены воскресенья – выходные). Или, скажем, паттерн чередования бригад: одна группа работает по схеме 2 через 2 дня. Эти шаблоны влияют на генерацию следующим образом: они определяют допустимые или предпочтительные комбинации. Реализация может быть через набор правил:
•	Пример 1: "Воскресенье – выходной для всех" можно задать как global правило: max_employees_per_shift с max = 0 на воскресенье (жесткое) – т.е. никого не должно быть на смене, или специальным флагом в shifts "store_closed": true, который алгоритм проверит.
•	Пример 2: "Суббота – минимальная нагрузка (не более 2 сменников)" – правило на субботний день с ограничением кол-ва рабочих.
•	Пример 3: шаблон чередования: Для таких сложных ротаций (например, бригада А и бригада Б, сменяются через неделю) лучше делать не правилами пост-фактум, а задать прямо планировщику фиксированные слоты для каждой бригады. Однако можно и правилом: индивидуальным – "Иванов работает только в недели №1 и №3 месяца, Петров – в №2 и №4" (довольно сложно через простые параметры, может потребовать выражения условий).
В целом, weekly_pattern используется как входные данные (какие смены существуют в какие дни) и как предпочтения. Мы реализуем поддержку шаблонов через конфигурацию смен и через правила-ограничения, чтобы не нарушать эти паттерны. Например, если магазин по воскресеньям закрыт, то при попытке поставить смену в воскресенье будет нарушено правило покрытия режима работы (см. далее). - Перекрытие режима работы магазина (cover_store_hours). Правило, гарантирующее, что все часы, когда магазин открыт, в расписании присутствуют сотрудники на смене. Технически, если у нас расписание состоит из смен, покрывающих день, и правило min_employees_per_shift для каждой смены >=1, то режим будет перекрыт. Но важно учесть, чтобы не было пробелов между сменами. Если, например, утренняя смена 8:00–16:00, а вечерняя 16:00–22:00, то правило coverage проверит, что нет ситуации, когда никто не выходит в 16:00 или 8:00 (обычно смены стыкуются). В случае кастомного графика может быть правило: первый сотрудник должен прийти не позже времени открытия и последний уйти не раньше закрытия. Это можно проверять: взять минимальное время начала смен из расписания каждого дня и максимальное время окончания – они должны сравняться с графиком работы магазина. Если нет – предупреждение или ошибка. Пример: магазин работает 9:00–21:00, а в расписании 5 января утренняя смена началась в 10:00 – нарушение правила, т.к. с 9 до 10 зал не укомплектован. - Балансировка нагрузки (balance_workload). Совокупность правил, направленных на справедливое и эффективное распределение работы между всеми сотрудниками. В простейшем случае – равное число смен каждому (с коррекцией на ставки). Более продвинутый подход – равное количество часов, либо равномерный распределение выходных дней. Можно реализовать несколько метрик баланса: - Равномерность смен: разница между сотрудниками по числу смен не превышает Х. - Равномерность выходных: чтобы у всех было примерно поровну выходных (или минимум определенное число). - Учёт ставок: если есть сотрудники с ограниченной ставкой (например, 20 часов в неделю), то баланс считается относительно их норм – т.е. полставки сотрудник не должен получать столько же смен, сколько сотрудник на полной ставке.
Правила баланса обычно ставятся как warnings с не самым высоким приоритетом (после основных ограничений), поскольку баланс – это цель оптимизации, а не жесткое требование. Тем не менее, система AutoSched поддерживает их: после заполнения основных потребностей, она будет стараться минимизировать дисбаланс. В интерфейсе это может отразиться, например, индексом равномерности или предупреждениями вроде "Иванов имеет на 3 смены больше среднего, Петров – на 2 меньше". - Обязательные роли в смене (required_roles_per_shift). Правило, гарантирующее, что каждая смена укомплектована необходимыми ролями. Например, в каждой смене должен быть хотя бы 1 старший смены и 1 кассир. Реализация: для каждой требуемой роли добавляется правило вида min_role_in_shift с параметрами role и min_count = 1 (или иное число). Эти правила scope = global (т.е. применимы ко всем сменам по умолчанию) или к определенным сменам, если не каждая смена требует эту роль. Например, ночная смена может требовать охранника, дневная – нет. Тогда делаем два правила: одно на ночную смену (role: Security, min_count:1), второе – на все смены (role: Manager, min_count:1). Алгоритм будет при подборе сотрудников на смену проверять эти условия: если в смене пока нет человека с ролью Х, он постарается кого-то из доступных с этой ролью поставить. Если нарушить невозможно (например, нет свободного менеджера на эту смену), это либо будет ошибкой (если правило жесткое – тогда расписание неполное, потребует вмешательства), либо предупреждением (и менеджер увидит, что "во вторник вечерняя смена без менеджера на точке" и, возможно, сам выйдет или кого-то перераспределит). - Выходные по заявкам (day_off_requests). Как упоминалось, утвержденные заявки – это фактически hard constraint, встроенный в механизм. Можно считать, что на каждую approved-заявку существует правило вроде "не назначать employee X на date Y". Они имеют высочайший приоритет, поскольку это решение менеджера/HR (или право сотрудника, например отпуск). Отдельно можно добавить правило-ограничение по количеству одобряемых заявок: например, "не больше N одобрений выходных в один день" – чтобы автоматически не одобрить слишком много и не парализовать работу. Но, скорее, это уже в процессе утверждения заявок надо контролировать (в модуле DayOffRequests можно предупреждать менеджера, что на 5 декабря уже трое просят выходной из отдела кассиров).
В контексте генерации, здесь важно то, что если запросы (особенно pending) рассматриваются, система может также их учитывать мягко. Например, если включено правило предпочтения сотрудников, pending-запрос "хочу выходной" будет трактован почти как пожелание: алгоритм постарается дать человеку этот выходной, но если не выйдет – поставит его на смену и пометит, что запрос не удовлетворен. - Предпочтения сотрудников (employees_preferences). Если эта функция активирована, авто-составление учитывает персональные пожелания, заданные сотрудниками или менеджером. Это могут быть: - Желаемые смены – напр. сотрудник А хочет работать по утрам, B – только во второй половине дня. - Нежелательные дни/часы – напр. студент просит не ставить ему смены во время учебы (понедельник утром у него пары, значит, нежелательно). - Парные предпочтения – некоторые сотрудники хотят/не хотят работать вместе в одну смену (из-за конфликтов или наоборот, наставничества). Такие кейсы тоже бывают: напр., "не ставить Иванова и Петрова вместе на одну смену (не ладят)", либо "желательно, чтобы новый сотрудник хотя бы 5 смен отработал с опытным сотрудником".
Технически, каждое такое предпочтение можно оформить как правило с enforcement = warning (потому что это не обязательство, а желание) и невысоким приоритетом. Например, "Иванов не хочет вечерние смены" – правило blacklist_shifts индивидуальное с shifts = ["evening"], warning, низкий приоритет. Или "Не ставить сотрудников X и Y вместе" – правило типа incompatible_pair: { "emp1": X, "emp2": Y }. Система при генерации попытается учесть – если есть альтернатива, она разведет их по разным сменам. Если же производственная необходимость – может нарушить (и отметить).
Предпочтения – мощный инструмент улучшения отношения сотрудников к расписанию. Современные системы (Deputy и др.) используют AI, чтобы повышать удовлетворенность, например, подбирая график, который максимально учитывает пожелания, при этом покрывая бизнес-требования. - Равномерность распределения смен (even_distribution). Частный случай балансировки – справедливость. Здесь акцент на том, чтобы все сотрудники получили более-менее равное количество смен или часов (с учетом их доступности). Правило может быть глобальным soft, сравнивающим экстремумы. Например: "разница между самым загруженным и самым свободным сотрудником по часам не больше 20%". Алгоритмически это сложное ограничение (нелинейное), но можно приближенно решать – например, добавляя штраф за каждую лишнюю смену сверх среднего. В AutoSched можно задать: balance_shifts: { "target_avg": true } – и движок добавит в целевую функцию штраф (shift_count_i - shift_count_j)^2 для всех пар i,j, минимизируя его. В результате стремится к равному распределению. Если же сделать правило, скажем, warning: "Если кто-то имеет >X смен сверх среднего – помечать", то уже после генерации система просто покажет предупреждение если условие нарушено. - Недопустимые смены (blacklist). Это общее название для правил, запрещающих определенные сочетания сотрудник-время. Как говорилось, можно запретить конкретному сотруднику определенные дни недели или типы смен (что равносильно индивидуальной доступности/недоступности). Также сюда попадают юридические ограничения: напр., несовершеннолетних не ставить на ночные смены – глобальное правило, применимое ко всем, но с условием по атрибуту сотрудника (age < 18, shift.type = night). Такие правила заранее можно предопределить: - no_night_for_minors (scope=global, enforcement=error): алгоритм проверяет каждое назначение: если сотрудник isMinor и shift ночной – запрещает. - no_overtime_for_role (напр., для должности "стажер" запрет сверхурочных часов, т.е. не более 8 час/день и 40 час/нед). - avoid_same_shift_for_relatives – если есть связанные сотрудники (родственники) – не ставить в одну смену, во избежание конфликта интересов.
Технически blacklist-правила могут быть представлены как особый случай либо через scope/target, либо как отдельный код с логикой. Главное – система поддерживает их, и менеджер может добавлять новые. Например, увидев проблему, можно добавить правило "не ставить Петрова на смены позже 20:00" – и далее планировщик это учтет.
Вышеописанные правила покрывают основные потребности: от базовых (минимум/максимум людей, ограничения по часам) до специфических (пожелания и несовместимости). Все они в AutoSched задаются конфигурацией и могут включаться/выключаться по мере необходимости.
Важно отметить, что порядок приоритетов очень значим. Обычно бизнес-жесткие ограничения (охрана труда, открытие магазина) ставятся с наивысшим приоритетом (1,2,…). Затем идут важные, но гибкие (максимум 5 дней подряд, роли в смене) – средний приоритет. Ниже – пожелания и баланс (8-10). Таким образом, система сначала удовлетворяет требования бизнеса и безопасности, потом – эффективность и комфорт сотрудников. Это соответствует подходу в коммерческих решениях: например, Deputy позволяет задать фокус либо на минимизации затрат, либо на равномерности, либо на учете предпочтений, что влияет на конечный график.
Алгоритм генерации расписания (AutoScheduler)
Алгоритм автогенерации в новой архитектуре работает итеративно и учитывает приоритеты правил на каждом шаге. Рассмотрим его общий поток:
1.	Инициализация и проверка данных. Алгоритм получает на вход все необходимые данные (список сотрудников, список смен, правила, одобренные выходные) через соответствующие DAO-слои или репозитории БД. Если какие-то данные отсутствуют (например, не заданы смены для указанного периода), он возвращает ошибку. Также может выполняться проверка на противоречивость входных правил – например, если есть явные конфликты (правило требует min 5 сотрудников, а всего сотрудников 4), система может сразу предупредить об этом.
2.	Предварительное назначение выходных и фиксированных элементов. Все сотрудник-дни, которые помечены как выходные (approved day off), сразу выставляются как занятые выходным. Это исключает этих сотрудников из пула доступных на соответствующие даты. Аналогично, если система поддерживает предзаполненные смены (например, менеджер заранее зафиксировал, что определенный ключевой сотрудник обязательно выйдет в конкретный день), эти фиксированные назначения тоже учитываются и не будут изменяться генератором. Таким образом, формируется частично заполненное расписание (может быть пустое, если ничего не было заранее задано).
3.	Генерация кадрового покрытия по дням. Автосоставление обычно идёт по временным слотам. Можно перебирать посуточно или посменно. Один из вариантов – цикл по дням: для каждого дня определить, какие смены должны быть покрыты (согласно шаблонам и режиму работы), и подобрать на них сотрудников. Однако, более оптимально рассматривать сразу весь диапазон, потому что распределение ресурсов должно быть глобально оптимальным (например, решение, кого поставить в субботу, может зависеть от того, сколько человек уже отработали к пятнице). Поэтому наш алгоритм работает глобально, но для описания можно представить так:
4.	Для каждого дня D и каждой смены S в этот день, если смена должна проводиться (магазин открыт, не выходной), формируется требование: нужно X сотрудников, включая определенные роли.
5.	Далее происходит назначение сотрудников на эту смену с учетом их доступности и уже назначенных выходных. Здесь алгоритм решает комбинаторную задачу назначения: из M сотрудников выбрать N, удовлетворяющих максимум условий. Используется приоритетная сортировка и подбор:
o	Сначала учитываются жесткие ограничения: сотрудник не может быть назначен, если у него уже есть смена в этот день (другое правило: 1 смена в день), если это его approved выходной, если он недоступен по времени (например, смена выпадает на его учебу), если это нарушит min_rest (например, работал прошлой ночью, а сейчас утро – тогда недопустимо). Таким образом, формируется список кандидатов на смену S, которые могут выйти.
o	Затем среди кандидатов ранжирование по приоритетам: предпочтительно те, чье назначение не вызовет нарушений важных правил. Например, если у кого-то назначение на эту смену приведет к 6-му дню подряд (нарушение max_consecutive_days), а у другого – нет, второй будет предпочтительнее. Если у кого-то есть предпочтение не работать в этот день (но это мягкое правило), а у другого нет предпочтений – второй предпочтительнее. Можно вычислять для каждого кандидата вес (приоритет) – чем меньше потенциальных нарушений с его участием, тем выше вес. В предыдущей версии использовалась формула приоритета, учитывающая нужду в выходном, текущие подряд дни и уже отработанные смены. Здесь формула станет более сложной: она может суммировать невыполнение всех soft-constraint для данного кандидата в данную смену. Но концептуально – самый "подходящий" сотрудник назначается первым.
o	Назначаем требуемое минимальное число сотрудников на смену, проходясь по отсортированному списку кандидатов. Если требуются определенные роли, убедимся, что хотя бы один подходящий по роли попал: например, если роль "старший" обязательна, сначала выбираем из кандидатов старшего. Если по каким-то причинам ни один старший недоступен, фиксируем, что правило нарушится (warning) и продолжим заполнение остальными.
o	Если минимальный состав не набирается (кандидатов меньше, чем min требуемых) – это критический случай: правило min_employees_per_shift нарушено. Алгоритм отметит это и, возможно, оставит позицию вакантной (чтобы потом менеджер вручную доназначил кого-то, возможно из перегрузившихся).
o	Если достигнут минимум и есть возможность добавить еще людей (до max_employees_per_shift), алгоритм решает, нужно ли добавлять. Добавление может происходить, если, например, у кого-то недобираются часы до нормы (и правило min_shifts_per_period для него нарушается) – тогда можно сверх минимума дать ему смену. Но обычно стараемся не превышать оптимальное число.
6.	Такой процесс продолжается для всех смен всех дней. В конце получается некоторая заполненность.
7.	Проверка и корректировка по правилам. После первичного заполнения, система проходит по всем правилам и проверяет, какие нарушены. Жесткие правила не должны быть нарушены к этому моменту – если вдруг есть (значит, решения нет в рамках жестких ограничений), система либо:
8.	а) сообщает, что полное расписание невыполнимо (например, сотрудников физически меньше, чем требуется по правилам),
9.	б) или автоматически понижает некоторые нарушенные жесткие правила до предупреждений (но лучше так не делать без ведома пользователя),
10.	в) или оставляет «дыры» (незаполненные смены) вместо нарушения – что по сути тоже сигнал проблемы.
Мягкие правила наверняка частично нарушены (редко когда все предпочтения и баланс сразу идеальны). Поэтому выполняется этап оптимизации: - Каждое нарушение имеет "цену" (вес обратный приоритету). Алгоритм пытается переставить или обменять назначения, чтобы снизить общий штраф. Здесь можно задействовать локальный поиск: например, если у одного сотрудника 6 дней подряд, а у другого в эти дни было меньше смен, попробовать одного из них заменить на части периода, чтобы у обоих стало по 5. Или если кассира назначили старшим на смену из-за нехватки, попробовать поменять местами кого-то с другой смены, чтобы старший попал куда надо. - Такие операции (swap, move) перебираются, если улучшают ситуацию по более приоритетному правилу не ухудшая более важные. Эта задача сложна, но применение метаэвристик (табу-поиск, имитация отжига) может найти хороший вариант расписания за разумное время даже при сотнях сотрудников. - Пример: правило равномерности – видим, что Иванов имеет 10 смен, Петров – 6, а обоим планировалось по 8. Найдем день, где Иванов работает, а Петров отдыхает, и попробуем их там поменять (если Петров доступен в тот день). Если это не нарушит других ограничений, обмен произведется, и баланс улучшится. Так последовательно можно сгладить различия. - Пример 2: 3 сотрудника попросили выходной в один день, а можно отпустить только 2 без ущерба. Алгоритм может определять, чей выходной снять (если заявки были pending). Тут уже требуется критерий – может, у кого меньше приоритет заявки или кто чаще брал выходные ранее.
После итераций корректировок система достигает точки, когда либо дальнейшее улучшение невозможно (локальный оптимум), либо время на расчет истекло. Полученный вариант – финальный. 5. Формирование результата и отчеты. Алгоритм возвращает сгенерированное расписание. Дополнительно генерируется отчет о нарушениях правил: список всех правил-warning, которые оказались нарушены, с подробностями (например: max_shifts_per_week: нарушен у 2 сотрудников (Иванов – 6 смен); employee_preferences: Петров назначен в нежелательный день 10 марта). Этот отчет отображается менеджеру в UI, чтобы он мог решить, устраивает ли его такой компромисс. Часть предупреждений он может проигнорировать, либо сразу поправить (система позволяет вручную внести правку и пересчитать только локально конфликт – например, самому дать Петрову выходной 10 марта и поставить другого, увидев предупреждение). Также отчет может использоваться для будущей аналитики: какие правила чаще всего конфликтуют, чтобы возможно пересмотреть требования или штат. 6. Запись и уведомление. Как описано ранее, расписание сохраняется в таблицу schedule_entries. После этого фронтенд может автоматически загрузить обновленные данные (эндпоинт GET /api/schedule?month=…), и уведомить ответственного, что расписание готово. Менеджер просматривает, вносит финальные корректировки при надобности и публикует его. Публикация может поменять статус расписания и разослать уведомления сотрудникам о их сменах.
Пример работы алгоритма с приоритетами: предположим, задано: мин 3 человека на смену (приоритет 1, error), не более 5 дней подряд для каждого (приоритет 2, error), учесть все approved выходные (приоритет 1, error), минимум 1 кассир на смене (приоритет 2, error), минимум 1 старший на смене (приоритет 3, warning), равномерность (приоритет 5, warning), учесть пожелания (приоритет 6, warning). Алгоритм строго выполнит первые четыре правила – т.е. ни одна смена не будет пустой, и в каждой минимум 3 сотрудника, кассир всегда будет, никто не будет работать 6 дней подряд, все утвержденные выходные соблюдены. Если где-то не хватает старшего – это будет предупреждение (значит, смена работает без старшего, что нежелательно, но приемлемо – менеджер может решить самому зайти или смириться). Баланс и пожелания будут стараться выполниться, но, скажем, если ради равномерности пришлось бы нарушить правило о 5 днях подряд – этого не случится. В итоге, может получиться, что один сотрудник имеет на 2 смены больше другого (баланс слегка нарушен) и чьи-то пожелания учтены не на 100%, зато критически важные аспекты соблюдены. Такой подход соответствует принципам автосоставления в индустрии: на первом месте – покрытие и соблюдение закона, на втором – эффективность и экономия, на третьем – удовлетворенность персонала.
UX: обработка конфликтов, уведомления и приоритизация
Последний аспект – как система взаимодействует с пользователем (менеджером расписания) при работе с автогенератором:
•	Выявление и отображение конфликтов. После генерации, если есть нарушения (warning-правила), интерфейс явно показывает их. Менеджер видит список конфликтов, отсортированный по важности (сначала предупреждения по правилам более высокого приоритета). Например:
•	Предупреждение: Отсутствует старший смены в 3 сменах (5, 12, 18 марта) – правило required_manager_per_shift.
•	Предупреждение: Петров превышает норму смен в неделю (6 смен на неделе 10-16 марта) – правило max_shifts_per_week.
•	Инфо: Желание Иванова иметь выходной 14 марта не выполнено – правило employee_preferences.
Каждая запись кликабельна: при выборе подсвечивает соответствующие дни/сотрудников в расписании. Это упрощает исправление – менеджер может сразу перейти к 14 марта и попробовать переставить Иванова. - Уведомления и workflow утверждения. AutoSched интегрирован с системой заявок на выходные: когда менеджер запускает генерацию расписания, он может получить предупреждение типа: "Учтено 5 заявок на отпуск, 2 заявки не удалось удовлетворить полностью". Он может просмотреть их и прямо из этого окна решить, что делать (например, позвонить сотрудникам или переутвердить). Кроме того, при наличии невыполненных требований (warning) система может предлагать варианты: например, "В смену 5 марта требуется старший – найти и добавить?" и кнопка Выбрать сотрудника. Это реализовано с помощью API "подбора": можно запросить у backend список кандидатов на эту незакрытую потребность, отсортированный по рейтингу (вроде call-list в Kronos, где предлагаются самые подходящие замены). Менеджер может одним кликом дозаполнить брешь. - Ручная правка с гарантией. В процессе корректировки расписания руками действует тот же валидатор. Если менеджер пытается нарушить жесткое правило (например, проставить 6-й день подряд) – система либо не даст сохранить изменение, либо спросит подтверждение в духе "Вы собираетесь нарушить правило X, вы уверены?". Для мягких правил – просто покажет предупреждение, которое можно проигнорировать. Это схоже с поведением Kronos Workforce Scheduler, где уровень правила "Warning" позволяет сохранить, а уровень "No Save" блокирует сохранение. - Визуализация приоритетов и правил. В интерфейсе настроек расписания есть раздел "Правила валидации", где перечислены все правила с указанием их статуса (включено/выключено), уровня и приоритета. Менеджер может изменить приоритет (например, решить, что для него баланс важнее пожеланий, и поднять соответствующее правило выше в списке). Мы предоставляем удобный UI для этого: список правил можно сортировать drag-and-drop, или изменять числовые приоритеты. При изменении конфигурации менеджер может сразу перегенерировать расписание. Для наглядности, можно представить условную диаграмму "треугольника приоритетов": наверху – самые строгие требования (от которых зависит работоспособность магазина и соблюдение законов), ниже – operational efficiency, внизу – employee happiness. Менеджер видит, на каком уровне какие правила, и может убеждаться, что, например, правило об учете предпочтений стоит намеренно ниже правила об ограничении подряд рабочих дней. - Протоколирование и отчеты. Система сохраняет историю автогенераций (кто запустил, когда, с какими параметрами). Это нужно, чтобы при расследовании проблем можно было понять, почему кто-то был так поставлен. Также собирается статистика: сколько раз какое правило нарушалось при генерации, сколько правок вручную сделал менеджер после авто, и т.п. Эти данные помогут улучшать систему. Например, если правило "равномерность" постоянно нарушается, возможно стоит пересмотреть доступность сотрудников или изменить приоритеты. - Масштабирование и производительность. Хотя это не напрямую UX, но важно: при росте числа сотрудников или сложностей система может дольше генерировать расписание. Поэтому реализован индикатор прогресса: после запуска автогенерации UI показывает статус (например, "Рассчитывается оптимальное расписание...") с прогресс-баром или анимацией. Если генерация занимает более нескольких секунд, бэкенд может отдавать промежуточные результаты (например, сначала план на первую неделю, потом на вторую) или хотя бы информировать, что происходит (возможно, через WebSocket). В любом случае, пользователь не остается в неизвестности.
В заключение, AutoSched представляет собой современную систему составления рабочего графика, сочетающую мощный движок оптимизации с богатой конфигурацией правил и удобным интерфейсом для конечного пользователя. Она автоматизирует рутинное планирование, минимизируя ручной труд и ошибки, делает расписание более комплаентным (соблюдение правил и законов) и эффективным (нет перебора/недобора персонала, контроль овертайма), а также учитывает интересы сотрудников (по возможности удовлетворяя запросы и предпочтения). Такой подход соответствует лучшим практикам индустрии: например, система Deputy позволяет одним кликом автосгенерировать расписание по заданным приоритетам – минимизации затрат, равномерности часов или соблюдению предпочтений, а Kronos Workforce Scheduler строго следит за соблюдением заданных правил и отмечает любые отклонения визуальными индикаторами. AutoSched берет эти идеи на вооружение, предоставляя магазину инструмент для автоматического создания оптимального графика, который можно сразу использовать или тонко настроить под специфические потребности.
Источники:
•	Auto-Scheduling best practices (Deputy) – приоритеты оптимизации (стоимость, равномерность), гибкие правила соответствия требованиям (отдых между сменами, макс. часы) и учет запросов/доступности сотрудников.
•	Kronos Workforce Scheduler (Surety Systems) – конфигурируемые правила (Employee/Org Rules), уровни строгости правил (Informational/Warning/No Save) и автоматическое предотвращение нарушений.
•	Walmart Global Tech – Automated Shift Scheduling – типовые ограничения в задаче составления расписания (мин. персонала на смене, 1 смена в день, 5 дней работы 2 выходных и пр.) и использование линейного программирования для решения.
•	StackExchange discussion on scheduling algorithms – упоминание эффективных алгоритмов (оптимизационные библиотеки, локальный поиск) для задач расписания.
•	Документация предыдущей версии RaboTA (RABOTA_SCHED.md) – анализ текущей реализации автогенерации и запросов на выходные, послуживший основой для требований новой версии.
________________________________________
